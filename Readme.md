参考 https://www.unrealengine.com/zh-CN/blog/unreal-property-system-reflection
虚幻引擎的C++反射是怎么实现的。

反射是程序在运行时检查自身的能力。  
这是非常有用的，是虚幻引擎的基础技术，支持许多系统，如编辑器中的详细面板，序列化，垃圾收集，网络复制，和Blueprint/ c++通信。  
然而，c++本身不支持任何形式的反射，所以虚幻有自己的系统来获取、查询和操作c++类、结构、函数、成员变量和枚举的信息。  
我们通常将反射称为属性系统，因为反射也是一个图形术语。  
反射系统是可选择的。你需要注释任何类型或属性，你想要可见的反射系统，和虚幻头工具(UHT)将收获这些信息，当你编译你的项目。  
标记要将头标记为包含反射类型，请在文件的顶部添加一个特殊的include。  
这让UHT知道他们应该考虑这个文件，这也是系统实现所需要的。  

UHT并不是真正的c++解析器。它能理解语言的一部分，并尽可能地跳过任何文本;只关注反射的类型、函数和属性。但是，有些东西仍然会使它混淆，所以在向现有的头文件添加反射类型时，您可能需要重写一些东西或将其包装在#if CPP / #endif对中。您还应该避免在任何带注释的属性或函数周围使用#if/#ifdef (WITH_EDITOR和WITH_EDITORONLY_DATA除外)，因为生成的代码会引用它们，并且在任何定义不为真的配置中会导致编译错误。  
大多数常见类型都按预期工作，但属性系统不能表示所有可能的c++类型(特别是只支持少数模板类型，如TArray和TSubclassOf，它们的模板参数不能是嵌套类型)。如果您注释了无法在运行时表示的类型，UHT将给您一个描述性错误消息。  
使用反射数据  
大多数游戏代码可以在运行时忽略属性系统，享受它所支持的系统的好处，但你可能会发现它在编写工具代码或构建玩法系统时很有用。  

虚幻构建工具(UBT)和虚幻头工具(UHT)协同作用，生成所需的数据，以推动运行时反射。UBT必须扫描报头来完成它的工作，它记住任何包含至少一种反射类型的报头的模块。  
如果自上次编译以来这些头中的任何一个发生了更改，那么将调用UHT来获取和更新反射数据。  
UHT解析头文件，构建一组反射数据，然后生成包含反射数据的c++代码(生成每个模块的.generated。Inl]，以及各种helper和thunk函数(per-header generated.h)。  
将反射数据存储为生成的c++代码的主要好处之一是，它可以保证与二进制代码同步。  
你永远不能加载陈旧或过时的反射数据，因为它是与引擎代码的其余部分一起编译的，它计算成员偏移量/等…在启动时使用c++表达式，而不是试图逆向工程特定平台/编译器/优化组合的打包行为。  
UHT也是作为一个独立的程序构建的，它不使用任何生成的头文件，因此它避免了UE3中脚本编译器经常抱怨的鸡和蛋的问题。  
生成的函数包括像StaticClass0 / StaticStruct0这样的东西，这使得很容易获得类型的反射数据，以及用于从blueprint或网络复制调用c++函数的thunk。  
这些必须声明为类或结构的一部分，这解释了为什么GENERATED_UCLASS_BODY()或GENERATED_USTRUCT_BODYO宏包含在你的反射类型中，以及定义这些宏的#include "TypeName.generated.h"。
